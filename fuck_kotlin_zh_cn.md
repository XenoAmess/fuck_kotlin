# 日了kotlin

## 0. 引子

作为一个资深java程序员，我憎恶kotlin，因为我对kotlin的部分设计非常反感。

我确定这不是由于我个人能力浅薄所致。

在我不算太漫长的从业经历中，我帮助apache-commons下的各个项目修复了数十个bug，并十余次修复因各种理由而不能正常运行的ci。

我帮助maven-javadoc-plugin修复过4个bug。

我帮助spring-boot修复过一个bug，帮助spring-common-data修复过另一个。

还有一些不那么广为人知的库我也修理过，包括lwjgl。

甚至，对于作为kotlin之父的jetbrains，我帮助jetbrains-idea修复过两个bug，一个是关于语法生成组件的，一个是关于反编译组件的。

我自己也维护了数十个java（或jvm语言）项目，其中有一小半现在还是有除了我以外的活人用户的。

所以我确信，现在的我有充足的经验，来宣称kotlin存在诸多在我看来匪夷所思的设计。

这本书最好是在看《Kotlin实战》之前看，作为洗脑预防补丁使用。次好的时间是在现在（如果你已经被kotlin炫丽的表象所魅惑了）。

## 1. 超脱谎言

当kotlin布道师告诉你，kotlin能**提供与java无限制的集成**（《Kotlin实战》原文），同时又告诉你，**Kotlin现在可以在JavaScript虚拟机上运行以支持全栈web开发，并且还将很快能够直接编译成原生代码，从而在需要的时候能够脱离任何的虚拟机来运行**（《Kotlin实战》原文）时，他们不会告诉你，事实上这两点是相互违背的。

作为一种所谓的高级语言，要么选择与底层语言更加耦合，以获取更多的复用底层语言已有的库/代码。 如type script于java script，cython于python，都是此类的代表。

与底层耦合过高的代价就是不能超脱。越与底层耦合，从底层能够复用的逻辑越多，就越无法抽离为一个抽象语言。

例如，我无法想象如何将cython抽离python，而以java作为宿主而使用。

我也很难想象如何将type script抽离java script，然后移植到python上去。

另一个选择则是相反，尽可能抽离，而与底层保持隔绝，以实现高级语言的超脱。

例如，java、C#等高级语言尽可能与平台相关代码抽离，以保证绝大部分内容可以跨平台使用。这里平台相关代码就可以视为意义上的底层代码。

所以java、C#等高级语言可以做到（绝大部分场景下）安全地跨平台使用。

想象这样一个场景: java本身（而不是jvm底层）可以调用英特尔某型号的CPU的特定汇编的特定语句。

如果java中直接包含这种能力，并且对于用户使用这种能力不加以任何限制，那么将该java代码视为跨平台是荒谬的，将java本身视为跨平台也是荒谬的。

而在kotlin上，我看到了混沌与贪婪。

一方面，kotlin的设计初衷决定了，它必须牢牢寄生在java之上。或者至少，牢牢寄生在jvm之上。

因为就连jetbrains恐怕也很难接受彻底将idea重写一遍，作为构造一门超脱的kotlin的代价。

毕竟，jetbrains作为一家商业公司，盈利产品是idea，而不是kotlin。kotlin的开发是为了更好的进行idea的开发，而不是反过来。

另一方面，kotlin又试图标榜自己具有超脱性，可以独立于jvm使用，而选取javascript作为宿主。

那么，有趣的问题来了。对于kotlin用户而言，当我们从网上获取了一段kotlin代码，我们并没有直观的方式可以看出这段代码是否可以在我们自身的场景
使用。

**它很美，它很kotlin，但是它使用了ConcurrentHashMap，所以无法在kotlin java script runtime使用**

这个问题没有造成非常恶劣的影响，颇具讽刺意味的，恰恰是因为kotlin除了寥寥几个公司会在java runtime使用外，几乎没有任何kotlin java script
 runtime的用户。

## 2. 兼容谎言

作为在kotlin踩了至少5回坑的java用户，我给你们一个忠告：

**永远不要相信kotlin可以与java完美兼容**

如果能再多一条，那么：

**可以有限度kotlin调用java。但是绝不要java调用kotlin。然后，双倍绝不要将自己的对外暴露的库从java改为kotlin。**

一个最容易产生问题的场景，恰恰是idea自身的场景。

作为多个idea插件的开发者或维护者，我经历了idea的多个模块从java迁移至kotlin的过程。

如果一个插件使用kotlin编写，而它依赖的库从java版本（旧）迁移至了kotlin版本（新），那么必须基于java版本（旧）进行构建。

如果你基于kotlin版本（新）进行构建，那么构建结果在java版本（旧）上，是不能保证完美兼容的。

那么，如果你需要基于新版本构建（一个市场事实是，90%以上的用户，不管正版还是盗版，都在使用最新的3个idea版本之一，所以理所当然我们更优先支持新版本），而同时又要保证在旧版本可用，唯一可行的方法是使用反射。甚至，某些极端场景下，有时候还必须使用kotlin调用java反射，而不是使用kotlin反射。

与宣传，以及大部分人的认知不同，从java走向kotlin事实上是一条单向通道。一旦超过某个界限，你就再也回不去了。

更糟糕的是，这个界限究竟在哪，对我们普通编码人员而言还是一个黑盒。

不要相信所谓的kotlin完美兼容java的论调。那是谎言。

## 3. 安全谎言

所谓的kotlin更加安全的论调，大多数最终只不过聚焦在NPE上。

首先，NPE与安全与否是否划等号，我个人持以怀疑态度。在我的潜意识里，安全更多的可能还是security manager，漏洞，提权那些东西。

似乎NPE只能算bug，而不能算是安全问题。否则我大概在各个仓库中修复了数百个安全问题 ———— 安全大师竟是我自己。

抛开上述不管，单论NPE，那么就我所见，kotlin充其量也不过是提供了一个强制化的JSR305。

如果在你的代码库中强行约束使用JSR305，那么可以达成一样的效果。

这方面在apache-commons的mailing list中，我在去年曾经建议过。现在这件事情Gary开了一个特性分支在推进……扯远了。

任何人都可以使用JSR305实现来轻而易举地进行NPE防护。

尤其是考虑jetbrains-idea是如此智能，以至于支持了多种JSR305实现的检测，其中包括无约束（jetbrains-annotation），静态增强约束（lombok），动态增强约束（spring）

作为对比，kotlin只提供了一种编译期的（或许也有运行时期，但这属于我盲区）强制约束，而没有进行提示但是不进行强制约束的选项。

所以我并不认为kotlin相比java有什么额外的安全性。

但是（话又说回来了），JSR305在项目中强制使用这一点，其实遵守的项目非常少。对此我抱有非常强烈的疑惑。

我想，大部分java程序员对于NPE的满不在乎之心才是应该被追责的重点。而其次则应该归咎于大部分代码规范都没有严格要求JSR305的使用。

## 4. 转换器谎言

就我个人的使用经验来看，所谓的”Java到Kotlin的转换器“就是一坨屎。

在我的为数不多的几次尝试经历中，几乎任何包含逻辑（非pojo）的类都不可能完美地完成等意义的转换。

## 5. 简洁谎言

**得益于Kotlin对类型推导的支持，你不再需要显式地声明类型，因此大部分关于静态类型的额外冗长代码也就不复存在了。**（《Kotlin实战》原文）

确实如此，但是问题在于，削去了类型相关显示定义后，代码编写人员想要看出这一变量的类型变得困难起来。

尤其是在脱离编译器场景：想象下你作为一个收到欢迎的开源库的维护者，当有一个人给你提交了一个一行变动的pr，你是否也可能选择直接在github观看代码，而不是拉到本地ide？毕竟偷懒是人类的天性，程序员尤甚。

对于编译器而言，类型推导可以帮助其确定该变量的类型，但是恐怕是要给程序员脑中也安装类型推导机才行。

不对函数返回值类型做硬性约束带来的结果可以是灾难性的：很多时候返回值类型并不影响调用方是否可编译，但是无意中造成的BC违背将对可维护性造成极大的问题。

就我目前的经历来看，依赖idea的kotlin部分就存在这种问题：BC还不多见，因为kotlin人还是有节操的。但是源码级不兼容则多的很。最多的是入参加了问号/去除了问号而产生的。别的原因产生的少一些。

这也是为什么kotlin（如果你确定要引入）我只建议作为调用方，而不要作为基础库被其他人调用的原因之一。（当然事实上我更建议如果可能，请彻底不要使用kotlin。）

## 多类合一文件问题

**但是你应该毫不犹豫地把多个类放进同一文件中，特别是那些很小的类。**（《Kotlin实战》原文）

那么我们应该如何按照目录检索自己想要的类呢?

当然，事实上，现在业界确实存在很多语言，不强制要求类的位置，而是允许多个类写在同一个文件中，比如C#。

但是我向来不推荐允许这种程度的灵活度。

另外，不论同一个kt文件中允许包含多少类，编译出的class文件总是每个类一个的。

多个类如果不能以一定的名称假定彼此间的文件关系，并彼此独立的进行反编译，那么我认为kotlin的反编译器构建会凭空添加很多复杂度：谁知道哪几个class是放在同一个kt里的呢？

这大概也是同样作为jvm语言，java可以拥有很多个不同组织实现的class->java的反编译器（虽然各有各的bug），而kotlin至今也没有一个能够使用的、后续也不可能出现一个能使用的class->kotlin的反编译器的原因之一。

……当然，这方面java自身做的也不够好。java是允许一个不为public的类"夹带"在一个别的类的文件中的……恶心。

A.java
```java
package com.xenoamess.fuck_kotlin;

class B {

}

public class A {
}

```

如上，A.java会被编译为A.class与B.class两个文件。而任何反编译器怕是都无法对其溯源了
